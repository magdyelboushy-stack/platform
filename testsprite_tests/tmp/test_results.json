[
  {
    "projectId": "6811c367-b881-420b-9f88-d284c28e063d",
    "testId": "27847b94-f5b0-4f5a-a773-2f53d906bf79",
    "userId": "c45874b8-c0b1-7082-9420-d49558a03f26",
    "title": "TC001-verify_csrf_token_endpoint_returns_fresh_token",
    "description": "Test the /api/csrf-token GET endpoint to ensure it returns a fresh CSRF token, a message, and a session_id with a 200 status code.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:8000\"\nAUTH_USERNAME = \"magdymohamed1929@gmail.com\"\nAUTH_PASSWORD = \"Magdy@2010\"\nTIMEOUT = 30\n\ndef test_verify_csrf_token_endpoint_returns_fresh_token():\n    url = f\"{BASE_URL}/api/csrf-token\"\n    try:\n        response = requests.get(url, auth=HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD), timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n        \n        json_data = response.json()\n        \n        assert isinstance(json_data, dict), \"Response is not a JSON object\"\n        assert \"csrf_token\" in json_data, \"'csrf_token' key missing in response\"\n        assert isinstance(json_data[\"csrf_token\"], str) and json_data[\"csrf_token\"], \"'csrf_token' should be a non-empty string\"\n        \n        assert \"message\" in json_data, \"'message' key missing in response\"\n        assert isinstance(json_data[\"message\"], str) and json_data[\"message\"], \"'message' should be a non-empty string\"\n        \n        assert \"session_id\" in json_data, \"'session_id' key missing in response\"\n        assert isinstance(json_data[\"session_id\"], str) and json_data[\"session_id\"], \"'session_id' should be a non-empty string\"\n        \n    except requests.RequestException as e:\n        raise AssertionError(f\"Request to CSRF endpoint failed: {e}\")\n\ntest_verify_csrf_token_endpoint_returns_fresh_token()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-25T10:15:18.329Z",
    "modified": "2026-01-25T10:15:32.495Z"
  },
  {
    "projectId": "6811c367-b881-420b-9f88-d284c28e063d",
    "testId": "33614f30-2b86-4719-929f-330296b22d0c",
    "userId": "c45874b8-c0b1-7082-9420-d49558a03f26",
    "title": "TC002-validate_user_login_with_correct_and_incorrect_credentials",
    "description": "Test the /api/auth/login POST endpoint with valid and invalid email/password combinations, including CSRF token validation, to verify successful login, unauthorized access, and account lockout after 5 failed attempts.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:8000\"\nCSRF_ENDPOINT = \"/api/csrf-token\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nTIMEOUT = 30\n\nAUTH_CREDENTIALS = {\n    \"username\": \"magdymohamed1929@gmail.com\",\n    \"password\": \"Magdy@2010\"\n}\n\ndef get_csrf_token(session):\n    try:\n        response = session.get(f\"{BASE_URL}{CSRF_ENDPOINT}\", timeout=TIMEOUT)\n        response.raise_for_status()\n        data = response.json()\n        csrf_token = data.get(\"csrf_token\")\n        assert csrf_token and isinstance(csrf_token, str)\n        return csrf_token\n    except Exception as e:\n        raise RuntimeError(f\"Failed to get CSRF token: {e}\")\n\ndef test_validate_user_login_with_correct_and_incorrect_credentials():\n    session = requests.Session()\n\n    # Basic Auth used for initial access per PRD's authType \"basic token\"\n    session.auth = HTTPBasicAuth(AUTH_CREDENTIALS[\"username\"], AUTH_CREDENTIALS[\"password\"])\n\n    csrf_token = get_csrf_token(session)\n\n    valid_payload = {\n        \"email\": AUTH_CREDENTIALS[\"username\"],\n        \"password\": AUTH_CREDENTIALS[\"password\"],\n        \"csrf_token\": csrf_token\n    }\n\n    invalid_payload = {\n        \"email\": AUTH_CREDENTIALS[\"username\"],\n        \"password\": \"WrongPassword!123\",\n        \"csrf_token\": csrf_token\n    }\n\n    # 1. Test successful login with correct credentials\n    try:\n        resp = session.post(f\"{BASE_URL}{LOGIN_ENDPOINT}\", json=valid_payload, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Expected 200 OK but got {resp.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Login with correct credentials failed: {e}\")\n\n    # 2. Test failed login with incorrect credentials - one attempt\n    try:\n        resp = session.post(f\"{BASE_URL}{LOGIN_ENDPOINT}\", json=invalid_payload, timeout=TIMEOUT)\n        assert resp.status_code == 401, f\"Expected 401 Unauthorized but got {resp.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Login with incorrect credentials failed unexpectedly: {e}\")\n\n    # 3. Test account lockout after 5 failed attempts\n    # The first failed attempt already made above, so 4 more attempts here\n    for attempt in range(4):\n        try:\n            # Refresh CSRF token to simulate fresh tokens per request\n            csrf_token = get_csrf_token(session)\n            invalid_payload[\"csrf_token\"] = csrf_token\n\n            resp = session.post(f\"{BASE_URL}{LOGIN_ENDPOINT}\", json=invalid_payload, timeout=TIMEOUT)\n            # For the first 4 attempts after the initial fail, expect 401 Unauthorized\n            if attempt < 3:\n                assert resp.status_code == 401, f\"Attempt {attempt+2}: Expected 401 Unauthorized but got {resp.status_code}\"\n            else:\n                # On the last failed attempt (5th), expect account lockout error\n                # The PRD mentions \"account locked temporarily\" but does not specify status code or message\n                # Assuming 401 Unauthorized still but with indication of lockout in response (common practice)\n                # We'll check status code and try to detect lockout if possible\n                assert resp.status_code == 401 or resp.status_code == 423, f\"Attempt 5: Expected 401 or 423 for lockout but got {resp.status_code}\"\n                # Optionally check response content for lockout indication\n                try:\n                    resp_json = resp.json()\n                    # It should have some error message indicative of lockout\n                    assert any(keyword in resp_json.get(\"message\", \"\").lower() for keyword in [\"locked\", \"lockout\", \"temporarily\"])\n                except Exception:\n                    # Cannot parse json or no lock message - it's still a pass if 401/423 returned\n                    pass\n        except Exception as e:\n            raise AssertionError(f\"Login attempt {attempt+2} failed unexpectedly: {e}\")\n\ntest_validate_user_login_with_correct_and_incorrect_credentials()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-25T10:15:18.335Z",
    "modified": "2026-01-25T10:15:43.049Z"
  },
  {
    "projectId": "6811c367-b881-420b-9f88-d284c28e063d",
    "testId": "70aea96c-fcf6-495d-8a86-dada7caa069a",
    "userId": "c45874b8-c0b1-7082-9420-d49558a03f26",
    "title": "TC003-validate_user_registration_with_valid_and_invalid_data",
    "description": "Test the /api/auth/register POST endpoint with valid and invalid user data including name, email, password, and CSRF token to verify successful user creation and proper handling of bad requests due to validation failures.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:8000\"\nAUTH = HTTPBasicAuth(\"magdymohamed1929@gmail.com\", \"Magdy@2010\")\nTIMEOUT = 30\n\ndef test_validate_user_registration_with_valid_and_invalid_data():\n    session = requests.Session()\n    session.auth = AUTH\n\n    # Get CSRF token\n    try:\n        csrf_resp = session.get(f\"{BASE_URL}/api/csrf-token\", timeout=TIMEOUT)\n        assert csrf_resp.status_code == 200, f\"Expected 200 from CSRF token endpoint, got {csrf_resp.status_code}\"\n        csrf_data = csrf_resp.json()\n        csrf_token = csrf_data.get(\"csrf_token\")\n        assert csrf_token and isinstance(csrf_token, str), \"CSRF token missing or invalid.\"\n    except Exception as e:\n        raise AssertionError(f\"Failed to get CSRF token: {e}\")\n\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Valid user data\n    valid_user = {\n        \"name\": \"Test User\",\n        \"email\": \"test.user+valid@example.com\",\n        \"password\": \"StrongPassw0rd!\",\n        \"csrf_token\": csrf_token\n    }\n\n    # Invalid user data sets (missing fields, invalid email, weak password)\n    invalid_users = [\n        # Missing name\n        {\n            \"email\": \"invalid1@example.com\",\n            \"password\": \"StrongPassw0rd!\",\n            \"csrf_token\": csrf_token\n        },\n        # Invalid email format\n        {\n            \"name\": \"Invalid Email\",\n            \"email\": \"invalid-email-format\",\n            \"password\": \"StrongPassw0rd!\",\n            \"csrf_token\": csrf_token\n        },\n        # Weak password (too short)\n        {\n            \"name\": \"Weak Password\",\n            \"email\": \"weak.password@example.com\",\n            \"password\": \"123\",\n            \"csrf_token\": csrf_token\n        },\n        # Missing csrf_token\n        {\n            \"name\": \"No CSRF\",\n            \"email\": \"no.csrf@example.com\",\n            \"password\": \"StrongPassw0rd!\"\n        }\n    ]\n\n    created_user_email = None\n\n    # Test valid registration (should return 201)\n    try:\n        resp = session.post(f\"{BASE_URL}/api/auth/register\", json=valid_user, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 201, f\"Expected 201 Created for valid registration, got {resp.status_code}\"\n        created_user_email = valid_user[\"email\"]\n    except Exception as e:\n        raise AssertionError(f\"Valid registration test failed: {e}\")\n\n    # Test invalid registrations (should return 400)\n    for idx, invalid_user in enumerate(invalid_users, start=1):\n        try:\n            resp = session.post(f\"{BASE_URL}/api/auth/register\", json=invalid_user, headers=headers, timeout=TIMEOUT)\n            assert resp.status_code == 400, f\"Expected 400 Bad Request for invalid user data set {idx}, got {resp.status_code}\"\n        except Exception as e:\n            raise AssertionError(f\"Invalid registration test case {idx} failed: {e}\")\n\n    # Cleanup: delete the created user if applicable\n    if created_user_email:\n        try:\n            # Assuming we have a user deletion endpoint: DELETE /api/users?email={email}\n            del_resp = session.delete(f\"{BASE_URL}/api/users\", params={\"email\": created_user_email}, timeout=TIMEOUT)\n            # It's okay if the user deletion endpoint is not implemented; no assertion here.\n        except Exception:\n            # Ignore any exception in cleanup\n            pass\n\ntest_validate_user_registration_with_valid_and_invalid_data()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 69, in test_validate_user_registration_with_valid_and_invalid_data\nAssertionError: Expected 201 Created for valid registration, got 422\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 92, in <module>\n  File \"<string>\", line 72, in test_validate_user_registration_with_valid_and_invalid_data\nAssertionError: Valid registration test failed: Expected 201 Created for valid registration, got 422\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-25T10:15:18.340Z",
    "modified": "2026-01-25T10:15:45.249Z"
  }
]
